package ca.umontreal.introduction.muzik;

import java.util.Iterator;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.FileNotFoundException;

import ca.umontreal.util.Error;

/**
* TSViTunesTrackReader is a class to interface TSV files from iTunes (File/Library/Export playlist)
* An instance is constructed using a file name.
* The file must be TSV format with tabs between fields (generated by iTunes).
* The instances of the file are accessed via an Iterator,
* ie using hasNext and next.
* Function next returns the next track while there are tracks in the file.
* Function hasNext returns false when there are no more tracks in the file.
* When hasNext becomes false, the file is closed.
* 
* @author      Francois Major
* @version     %I%, %G%
* @since       1.0
*/
public class TSViTunesTrackReader implements Iterator<iTunesTrack> {

    private String fileName;
    private FileReader reader;
    private BufferedReader bufferReader;
    private String line;

    /**
     * Constructor with a file name argument.
     * The file name is kept in the instance, which also
     * uses a FileReader, a BufferedReader, and a String line as a line buffer.
     * <p>
     * This constructor assumes a TSV file with a header in the first line,
     * which is skipped. The line is set to the first line of data.
     *
     * @param  fileName   the file name with complete path
     * @see               Track
     */
    public TSViTunesTrackReader( String fileName ) {
	this.fileName = fileName;
	// create new Track
	try {
	    this.reader = new FileReader( this.fileName );
	} catch( FileNotFoundException e ) {
	    Error.generalError( "FileNotFound " + this.fileName );
	}
	try {
	    this.bufferReader = new BufferedReader( this.reader );
	    // read the header of the csv file (title bar)
	    this.line = this.bufferReader.readLine();
	    // position to first line of data
	    this.line = this.bufferReader.readLine();
	} catch( IOException e ) {
	    Error.generalError( "IO Exception caught" );
	}
    }

    /**
     * Create and return an instance of Track that matches the current this.line.
     * Then, it modifies this.line to match the following line of data.
     *
     * @return      the Track instance corresponding to this.line
     * @see         Track
     */
    public iTunesTrack next() {
	// next data are in this.line
	// parse the line from iTunes Export playlist function
	// 31 pieces seperated by tabs
	iTunesTrack track = new iTunesTrack();
	String[] data = this.line.split( "\\t", 31 );
	String name = data[0];
	String artist = data[1];
	String composer = data[2];
	String album = data[3];
	String grouping = data[4];
	String work = data[5];
	String movementNumber = data[6];
	String movementCount = data[7];
	String movementName = data[8];
	String genre = data[9];
	String size = data[10];
	String time = data[11];
	String discNumber = data[12];
	String discCount = data[13];
	String trackNumber = data[14];
	String trackCount = data[15];
	String year = data[16];
	String dateModified = data[17];
	String dateAdded = data[18];
	String bitRate = data[19];
	String sampleRate = data[20];
	String volumeAdjustment = data[21];
	String kind = data[22];
	String equalizer = data[23];
	String comments = data[24];
	String plays = data[25];
	String lastPlayed = data[26];
	String skips = data[27];
	String lastSkipped = data[28];
	String myRating = data[29];
	String location = "";
	if( data.length > 30 ) location = data[30];
	// Track setters
	track.setName( name );
	track.setArtist( artist );
	track.setComposer( composer );
	track.setAlbum( album );
	track.setGrouping( grouping );
	track.setWork( work );
	track.setMovementNumber( movementNumber );
	track.setMovementCount( movementCount );
	track.setMovementName( movementName );
	track.setGenre( genre );
	track.setSize( size );
	track.setTime( time );
	track.setDiscNumber( discNumber );
	track.setDiscCount( discCount );
	track.setTrackNumber( trackNumber );
	track.setTrackCount( trackCount );
	track.setYear( year );
	track.setDateModified( dateModified );
	track.setDateAdded( dateAdded );
	track.setBitRate( bitRate );
	track.setSampleRate( sampleRate );
	track.setVolumeAdjustment( volumeAdjustment );
	track.setKind( kind );
	track.setEqualizer( equalizer );
	track.setComments( comments );
	track.setPlays( plays );
	track.setLastPlayed( lastPlayed );
	track.setSkips( skips );
	track.setLastSkipped( lastSkipped );
	track.setMyRating( myRating );
	track.setLocation( location );

	// position the reader to the next line
	try {
	    this.line = this.bufferReader.readLine();
	} catch( IOException e ) {
	    Error.generalError( "IO Exception caught" );
	}
	// return the new Track
	return track;
    }

    public boolean hasNext() {
	if( this.line != null ) return true;
	try {
	    this.bufferReader.close();
	} catch( IOException e ) {
	    Error.generalError( "Something wrong happened at closing the bufferReader" );
	}
	return false;
    }
}
